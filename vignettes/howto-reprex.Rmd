---
title: "Workflow: How to use the serosurvey R package?"
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)
knitr::opts_chunk$set(fig.width=10, fig.height=4)
options(tidyverse.quiet = TRUE)
```

## Context

__Problem__

- If we used an imperfect test, we need to incorporate the test uncertainty into the sampling design uncertainty. 

__Method details__

- Here we applied a Bayesian method to estimate the posterior probability of seroprevalence for a test with unknown performance [@Larremore2020unk].

- As inputs we used the expanded point estimate number of positive tests and total population that resulted from the sampling weights adjusted seroprevalence estimation. 

- To maintain the sampling design uncertainty, we applied the same method for each estimated confidence interval. 

- Since test sensitivity and specificity were unknown, we used the reported number of true positives, false positives, true negatives and false negatives from a local test performance evaluation.

- For this worlflow we used lab validation results from an 
example available in the `epiR` package: `?epiR::epi.tests`

  + for sensitivity: Of 744 patients that were disease positive, 670 were test positive.
  + for specificity: Of 842 patients that were disease negative, 640 were test negative.

__Procedure details__

- Test correction functions require positive integers.

- We use `purrr` and `furrr` to efficiently update prevalence posterior distributions for multiple prevalences in one pipe


__Limitations__

- We do not apply a multiple subpopulation aproach for the inference
of prevalence. This is currently available for a test with known performance [@Larremore2020kno].

- This workflow is only applicable to categorical variables.

- `set.seed` could not control the variability generated by test correction functions.

## Import packages

```{r setup}
# package
library(serosurvey)
# additional
library(tidyverse)
library(srvyr)
library(survey)
library(tictoc)
library(furrr)
library(purrr)
# theme
theme_set(theme_bw())
```

## Import data

```{r}
data(api)

datasurvey <- apiclus2 %>% 
  mutate(survey_all="survey_all") %>% 
  # create variables
  mutate(outcome_one = awards,
         outcome_two = cut(pct.resp,breaks = 2),
         covariate_01 = stype,
         covariate_02 = both)

# datasurvey %>% glimpse()
```

### `srvyr` workflow

```{r,eval=FALSE}
dstrata <- datasurvey %>% as_survey_design(strata = covariate_01, weights = pw)
# dstrata2 <- apistrat %>%
#   mutate(pw2=1) %>%
  # as_survey_design(strata = covariate_01, weights = pw2)
dstrata %>%
  summarise(pct = survey_mean(outcome_one=="Yes",proportion = TRUE))
# dstrata2 %>%
#   summarise(pct = survey_mean(outcome_one=="Yes",proportion = TRUE))
```


## Select set of covariates

```{r}

# denominators
covariate_set01 <- datasurvey %>% 
  select(covariate_01,
         #covariate_03,
         #covariate_04,
         covariate_02) %>% 
  colnames()

# numerators within outcome
covariate_set02 <- datasurvey %>% 
  select(#covariate_01,
         #covariate_03
         #covariate_04
         covariate_02) %>% 
  colnames()

```

## Prevalence estimation

```{r}
# tratamiento de stratos con un solo conglomerado
options(survey.lonely.psu = "certainty")

# uu_clean_data %>% count(CONGLOMERADO,VIVIENDA)

# dise√±o muestral de la encuesta ---------------------------------

design <- datasurvey %>% 
  
  filter(!is.na(outcome_one)) %>% #CRITICAL! ON OUTCOME
  filter(!is.na(pw)) %>% #NO DEBEN DE HABER CONGLOMERADOS SIN WEIGHT
  
  as_survey_design(
    id=c(dnum, snum), #~dnum+snum, # primary secondary sampling unit
    # strata = strata, #clusters need to be nested in the strata
    weights = pw # factores de expancion
  )
```

## Example: Single estimation

```{r}
serosvy_proportion(design = design,
                      denominator = covariate_01,
                      numerator = outcome_one) %>%
  select(-ends_with("_low"),-ends_with("_upp"),
         -ends_with("_cv"),-ends_with("_deff"))

serosvy_proportion(design = design,
                      denominator = outcome_one,
                      numerator = covariate_01) %>%
  select(-ends_with("_low"),-ends_with("_upp"),
         -ends_with("_cv"),-ends_with("_deff"))
```

## __Workflow:__ Multiple estimation

## 1. Estimates: raw + weighted

```{r}
# _ 1. estimates: raw + weighted ---------------------------------------------------------------

outcome_01_pre <- 
  # crear matriz
  #
  # set 01 of denominator-numerator
  #
expand_grid(
  design=list(design),
  denominator=c("covariate_01","covariate_02"), # covariates
  numerator=c("outcome_one","outcome_two") # outcomes
  ) %>% 
  #
  # set 02 of denominator-numerator (e.g. within main outcome)
  #
  union_all(
    expand_grid(
      design=list(design),
      denominator=c("outcome_one","outcome_two"), # outcomes
      numerator=c("covariate_02") # covariates
    )
  ) %>% 
  #
  # create symbols (to be readed as arguments)
  #
  mutate(
    denominator=map(denominator,dplyr::sym),
    numerator=map(numerator,dplyr::sym)
  ) %>% 
  #
  # estimate prevalence
  #
  mutate(output=pmap(.l = select(.,design,denominator,numerator),
                     .f = serosvy_proportion)) %>% 
  #
  # show the outcome
  #
  select(-design,-denominator,-numerator) %>% 
  unnest(cols = c(output)) #%>% 

outcome_01_pre

```

## 2. Add uncertain test performance

Lets assume that we have results from a local validation study

### 2.1 Filter + add validation study results

```{r}
# _ 2. test performance ---------------------------------------------------

# __ filter + add values --------------------------------------------------

outcome_01_adj_pre <- outcome_01_pre %>% 
  # only serological results
  filter(numerator=="outcome_one") %>% 
  # only positives
  filter(numerator_level=="Yes") %>% 
  # round numbers are required
  mutate_at(.vars = vars(total,total_den,
                         total_low,total_den_low,
                         total_upp,total_den_upp),
            .funs = list("round"=round),digits = 0) %>%
  # unknown test local validation results
  # for sensitivity:
  # Of 744 patients that were disease positive, 670 were test positive.
  # for specificity:
  # Of 842 patients that were disease negative, 640 were test negative.
  # source: ?epiR::epi.tests
  mutate(
    true_positive = 670,
    false_negative = 74,
    false_positive = 202,
    true_negative = 640
  ) %>% 
  rownames_to_column() %>%
  mutate(rowname=as.numeric(rowname))

```

### 2.2 Apply + extract

```{r}
# __ apply + extract ----------------------------------------------------------------
# 56-60sec por covariable 
# 4GB RAM
# paralelizando en 8 nucleos usando purrr y furrr

plan(multisession, workers = availableCores())
tic()

out <- tibble()

for (i in 1:nrow(outcome_01_adj_pre)) {
  
  out <- outcome_01_adj_pre %>% 
    
    slice(i) %>% 
    
    # dot
    mutate(adj_dot_unk=future_pmap(
      .l = select(.,
                  positive_number_test=total_round,
                  total_number_test=total_den_round),
      .f = possibly(serosvy_unknown_sample_posterior,otherwise = NA_real_),
      true_positive = true_positive,
      false_negative = false_negative,
      false_positive = false_positive,
      true_negative = true_negative)) %>% 
    serosvy_extract_posterior(variable = adj_dot_unk) %>% 
    
    # low
    mutate(adj_low_unk=future_pmap(
      .l = select(.,
                  positive_number_test=total_low_round,
                  total_number_test=total_den_low_round),
      .f = possibly(serosvy_unknown_sample_posterior,otherwise = NA_real_),
      true_positive = true_positive,
      false_negative = false_negative,
      false_positive = false_positive,
      true_negative = true_negative)) %>%
    serosvy_extract_posterior(variable = adj_low_unk) %>%
    
    # upp
    mutate(adj_upp_unk=future_pmap(
      .l = select(.,
                  positive_number_test=total_upp_round,
                  total_number_test=total_den_upp_round),
      .f = possibly(serosvy_unknown_sample_posterior,otherwise = NA_real_),
      true_positive = true_positive,
      false_negative = false_negative,
      false_positive = false_positive,
      true_negative = true_negative)) %>%
    serosvy_extract_posterior(variable = adj_upp_unk) %>% 
    
    # union all outputs
    union_all(out)
  
  # activate to print the progress! (recommended)
  # out %>% print() #%>% 
  
  # # known test
    # mutate(adj_dot_kno=future_pmap(
    #   .l = select(.,
    #               positive_number_test=total_round,
    #               total_number_test=total_den_round),
    #   .f = possibly(serosvy_known_sample_posterior,otherwise = NA_real_),
    #   sensitivity=0.999,
    #   specificity=0.960))
  
}

toc()

outcome_01_adj <- out  %>% 
  mutate(rowname=as.numeric(rowname)) %>% 
  arrange(rowname) %>% 
  select(-rowname) 
```

## 3. Create output format

```{r}

# _ 3. create output format -----------------------------------------------



outcome_01_adj_tbl <- 
  # start from original dataset
  outcome_01_pre %>% 
  # only positives
  filter(numerator_level=="Yes"|denominator_level=="Yes") %>% 
  # left join with db with test performance update
  left_join(outcome_01_adj) %>% 
  # naniar::miss_var_summary() %>% 
  # avallecam::print_inf() %>% 
  
  # apply format
  unite_dotwhiskers(variable_dot = raw_prop, 
                    variable_low = raw_prop_low,
                    variable_upp = raw_prop_upp,
                    digits_dot = 2,
                    digits_low = 1,
                    digits_upp = 2) %>% 
  unite_dotwhiskers(variable_dot = prop, 
                    variable_low = prop_low,
                    variable_upp = prop_upp,
                    digits_dot = 2,
                    digits_low = 1,
                    digits_upp = 2) %>% 
  unite_dotwhiskers(variable_dot = adj_dot_unk_p50,
                    variable_low = adj_low_unk_p50,
                    variable_upp = adj_upp_unk_p50,
                    digits_dot = 3,
                    digits_low = 2,
                    digits_upp = 3)
```

## 4. Evaluate output

```{r}
# _ 4. evaluate output ----------------------------------------------------


outcome_01_adj_tbl %>% 
  select(1:4,starts_with("unite1_")) %>% 
  # view()
  # avallecam::print_inf()
  knitr::kable() %>% 
  kableExtra::kable_styling(bootstrap_options = "striped", full_width = F)

```

## Output figure

```{r}
outcome_01_adj_tbl %>% 
  ggplot_prevalence(
    category = denominator_level,
    outcome = numerator,
    proportion = prop,
    proportion_upp = prop_upp,
    proportion_low = prop_low) +
  theme(axis.text.x = element_text(angle = 0, vjust = 0, hjust=0)) +
  coord_flip() +
  facet_wrap(denominator~.,scales = "free_y") +
  # facet_grid(denominator~.,scales = "free_y") +
  colorspace::scale_color_discrete_qualitative() +
  labs(title = "Prevalence of numerators across denominators",
       y = "Prevalence",x = "")
```

## Reference
