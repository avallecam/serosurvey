---
output: github_document
editor_options: 
  chunk_output_type: console
bibliography: references.bib
link-citations: yes
linkcolor: Blue
urlcolor: Blue
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  echo = TRUE,
  message = FALSE,
  warning = FALSE
)
knitr::opts_chunk$set(fig.width=10, fig.height=4)
options(tidyverse.quiet = TRUE)
```
# serosurvey

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![CRAN status](https://www.r-pkg.org/badges/version/serosurvey)](https://cran.r-project.org/package=serosurvey)
<!-- badges: end -->

The goal of `serosurvey` is to gather _functions_ and _workflow templates_ for __Serological Survey Analysis For Prevalence Estimation Under Misclassification__.

## Installation

<!-- You can install the released version of serosurvey from [CRAN](https://CRAN.R-project.org) with: -->

``` r
if(!require("devtools")) install.packages("devtools")
devtools::install_github("avallecam/serosurvey")
```

## Example

This is a basic example which shows you how to solve a common problem:

```{r example}
library(serosurvey)
```

```{r,echo=FALSE}
# additional
library(tidyverse)
library(srvyr)
library(survey)
library(tictoc)
library(furrr)
library(purrr)
# theme
theme_set(theme_bw())
```

```{r,echo=FALSE}
data(api)

datasurvey <- apiclus2 %>% 
  mutate(survey_all="survey_all") %>% 
  # create variables
  mutate(outcome_one = awards,
         outcome_two = cut(pct.resp,breaks = 2),
         covariate_01 = stype,
         covariate_02 = both)
```

```{r,echo=FALSE}
# tratamiento de stratos con un solo conglomerado
options(survey.lonely.psu = "certainty")

# uu_clean_data %>% count(CONGLOMERADO,VIVIENDA)

# dise√±o muestral de la encuesta ---------------------------------

design <- datasurvey %>% 
  
  filter(!is.na(outcome_one)) %>% #CRITICAL! ON OUTCOME
  filter(!is.na(pw)) %>% #NO DEBEN DE HABER CONGLOMERADOS SIN WEIGHT
  
  as_survey_design(
    id=c(dnum, snum), #~dnum+snum, # primary secondary sampling unit
    # strata = strata, #clusters need to be nested in the strata
    weights = pw # factores de expancion
  )
```

```{r,echo=FALSE}
# denominadores
covariate_set01 <- datasurvey %>% 
  select(covariate_01,
         #sch.wide,
         #comp.imp,
         covariate_02) %>% 
  colnames()

# numerators within outcome
covariate_set02 <- datasurvey %>% 
  select(#stype,
         #sch.wide,
         #comp.imp,
         covariate_02) %>% 
  colnames()
```

### `survey`: Estimate single prevalences

- From a __`srvyr` survey design object__, __`serosvy_proportion`__ estimates:

  + weighted prevalence (`prop`), 
  + total population (`total`),
  + raw proportion (`raw_prop`), 
  + coefficient of variability (`cv`), 
  + design effect (`deff`)

```{r}
serosvy_proportion(design = design,
                   denominator = covariate_01,
                   numerator = outcome_one)


serosvy_proportion(design = design,
                   denominator = outcome_one,
                   numerator = covariate_01)
```

```{r,eval=FALSE}
example("serosvy_proportion")
```

### `survey`: Estimate multiple prevalences

- In 
the [Article tab](https://avallecam.github.io/serosurvey/articles/howto-reprex.html) 
we provide a workflow to __estimate multiple prevalences__: 

  + using _different set of covariates_ and outcomes as numerators or denominators,
  + in _one single pipe_ operation

```{r}
# crear matriz
  #
  # set 01 of denominator-numerator
  #
expand_grid(
  design=list(design),
  denominator=c("covariate_01","covariate_02"), # covariates
  numerator=c("outcome_one","outcome_two") # outcomes
  ) %>% 
  #
  # set 02 of denominator-numerator (e.g. within main outcome)
  #
  union_all(
    expand_grid(
      design=list(design),
      denominator=c("outcome_one","outcome_two"), # outcomes
      numerator=c("covariate_02") # covariates
    )
  ) %>% 
  #
  # create symbols (to be readed as arguments)
  #
  mutate(
    denominator=map(denominator,dplyr::sym),
    numerator=map(numerator,dplyr::sym)
  ) %>% 
  #
  # estimate prevalence
  #
  mutate(output=pmap(.l = select(.,design,denominator,numerator),
                     .f = serosvy_proportion)) %>% 
  #
  # show the outcome
  #
  select(-design,-denominator,-numerator) %>% 
  unnest(cols = c(output)) %>% 
  print(n=Inf)
```

### `serology`: Estimate prevalence Under misclassification

- We gather __classical frequentist approaches__ to deal with 
misclassification due to an imperfect diagnostic test.
Check the [functions documentation tab](https://avallecam.github.io/serosurvey/reference/index.html).

- We provide __tidy outputs for bayesian approaches__ developed in @Larremore2020unk [here](https://github.com/LarremoreLab/bayesian-joint-prev-se-sp/blob/master/singleSERO_uncertainTEST.R) and @Larremore2020kno [here](https://github.com/LarremoreLab/covid_serological_sampling/blob/master/codebase/seroprevalence.R):

- You can use them with __`purrr`__ and __`furrr`__ to efficiently iterate and parallelize this step for __multiple prevalences in one single pipe__.
Check the workflow 
in [Article tab](https://avallecam.github.io/serosurvey/articles/howto-reprex.html).


#### __Known test performance - Bayesian method__

```{r}
tidy_result <- serosvy_known_sample_posterior(
  #in population
  positive_number_test = 321,
  total_number_test = 321+1234,
  # known performance
  sensitivity = 0.93,
  specificity = 0.975
)
```

```{r,echo=FALSE}
tidy_result_out <-
  tidy_result %>%
  select(summary) %>%
  unnest(cols = c(summary))

tidy_result %>%
 select(posterior) %>%
 unnest(cols = c(posterior)) %>%
 ggplot(aes(x = r1)) +
 geom_histogram(aes(y=..density..),binwidth = 0.0005) +
 geom_density() +
 geom_vline(aes(xintercept=tidy_result_out %>%
                  pull(numeric.mean)),
            color="red",lwd=1) +
 geom_vline(aes(xintercept=tidy_result_out %>%
                  pull(numeric.p05)),
            color="red") +
 geom_vline(aes(xintercept=tidy_result_out %>%
                  pull(numeric.p95)),
            color="red") +
 scale_x_continuous(breaks = scales::pretty_breaks())
```

```{r,eval=FALSE}
example("serosvy_known_sample_posterior")
```

#### __Unknown test preformance - Bayesian method__

- The test performance is defined as _unknown_ or _uncertain_ "when the test 
characteristics are not well defined and a limited number of test are 
available, such as during an outbreak of a novel pathogen." [@Larremore2020unk; @Diggle2011]

```{r,eval=FALSE,echo=FALSE}
# result_unk <- sample_posterior_r_mcmc_testun(
#   samps = 10000,
#   #in population
#   pos = 692, #positive
#   n = 3212, #total
#   # in lab (local validation study)
#   tp = 670,tn = 640,fp = 202,fn = 74)
```

```{r}
result_unk <- serosvy_unknown_sample_posterior_ii(
  #in population
  positive_number_test = 321,
  total_number_test = 321+1234,
  # in lab (local validation study)
  true_positive = 670,
  true_negative = 640,
  false_positive = 202,
  false_negative = 74)
```

```{r,echo=FALSE}
result_unk %>%
  select(posterior) %>% 
  unnest(posterior) %>%
  rownames_to_column() %>%
  pivot_longer(cols = -rowname,
               names_to = "estimates",
               values_to = "values") %>%
  ggplot(aes(x = values)) +
  geom_histogram(aes(y=..density..),binwidth = 0.0005) +
  geom_density() +
  facet_grid(~estimates,scales = "free_x")
```

```{r,eval=FALSE}
example("serosvy_unknown_sample_posterior")
```

## Contribute

Feel free to fill an issue or contribute with your functions or workflows. 

Here are two articles with interesting approaches using R:

- @Silveira2020 in the strategy 3 analysed the survey accounting for sampling design and test validity using parametric bootstraping.

- @Flor2020 implemented a lot of frequentist and bayesian methods for test with known sensitivity and specificity. Code is available [here](https://github.com/BfRstats/bayespem-validation-code)


## References

<div id="refs"></div>

## How to cite this R package

```{r}
citation("serosurvey")
```

